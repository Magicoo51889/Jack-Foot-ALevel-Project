# 2.2.3 Cycle 3

## Design <a href="#design" id="design"></a>

### Objectives <a href="#objectives" id="objectives"></a>

In this cycle I aim to be creating an enemy class that I can re-use to reduce the amount of code being written, so that the game is smaller to load and run. This makes it less intensive for slower computers and means that my code is better structured and easier to read/debug. Additionally I will add all the enemies to an array to be able to make them grouped together and to be able to call different elements in the array for different enemy types, making it easier to quickly add an enemy later on in the game's development.&#x20;

Furthermore I will be implementing a key system to be able to identify different objects in the game so that I can track what object is which with a simple sting of characters, which could be in 4 bit binary as this would allow for 16 different unique keys for things such as the player or the player's lasers, or the enemies.

* [x] Create enemy class
* [x] Enemy loads into the game
* [ ] Unique object keys

### Usability Features <a href="#usability-features" id="usability-features"></a>

### Key Variables <a href="#key-variables" id="key-variables"></a>

| Variable Name       | Use                                                                                                                                            |
| ------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| \[OBJECT]\_CATEGORY | This constant is one that is assigned to each different object, which is unique to that one object, and makes identifying each object easier.  |

### Pseudocode <a href="#pseudocode" id="pseudocode"></a>

```
class Enemy extends Phaser Sprite
    target = this.target
    scene = current scene
    
    scene: Phaser.scene
    X: Number
    Y: Number
    texture: string
    
    create(texture)
        add image (X, Y, texture)
        
    set the this.target as the target
    
    procedure Update
        if target doesn't exist
            return
        else
            tx = target.x
            ty = target.y
            x = this.x
            y = this.y
            rotation = angle between (tx and ty, x and y)
            rotate to rotation
    end procedure
end class
            
        
```

## Development <a href="#development" id="development"></a>

### Outcome <a href="#outcome" id="outcome"></a>

{% tabs %}
{% tab title="enemy.ts" %}
```typescript
import Phaser from "phaser";

export default class Enemy extends Phaser.GameObjects.Sprite {
    private target?: Phaser.GameObjects.Components.Transform;
    scene: any;

    constructor(scene, x: number, y: number, texture: string, health: number) {
        super(scene, 0, 0, texture);
        this.scene.add.existing(this);
        this.x = x
        this.y = y
    }

    create(texture: string) {
        this.scene.add.image(this.x, this.y, texture);
        console.log("enemy created as " + texture);
    }

    set_Target(target: Phaser.GameObjects.Components.Transform) {
        this.target = target;
        console.log("finding target");
    }

    update() {
        // points towards the player
        if (!this.target){
            console.log("no target");
            return
        }
        
        console.log("target found");
        const tx = this.target.x
        const ty = this.target.y
        const x = this.x
        const y = this.y
        const rotation = Phaser.Math.Angle.Between(x, y, tx, ty)
        this.setRotation(rotation)
        console.log("rotating to " + rotation);
    }
}
```
{% endtab %}

{% tab title="playScene.ts" %}
{% code title="playScene.ts" %}
```typescript
let enemy = new Enemy(this, window.innerWidth / 2, (window.innerHeight / 4), 'enemy', 100);
enemy.create('enemy');
```
{% endcode %}
{% endtab %}
{% endtabs %}

### Challenges <a href="#challenges" id="challenges"></a>

It was quite challenging to work out and figure what functionality I first needed in my enemy class to be able to get it to work, and I needed to figure out what would be essential and found in every enemy that I made. This means that every enemy I made had to have all of these common features, so it was essential that I got them right.&#x20;

Implementing the enemy into the game was a bit tricky to begin with as there's not much documentation on how to use a class as a sprite or game object, and you have to figure it out yourself. The way I did it allows me to use a function within the class itself to be able to make the enemy, and this in turn loads the image, based on where I input the x and y to be. This allows me to keep the enemy class separate from the main scene code, making it easier to debug and to modularise the program.&#x20;

## Testing <a href="#testing" id="testing"></a>

Evidence for testing

### Tests <a href="#tests" id="tests"></a>

| Test               | Instructions           | What I expect                                          | What actually happens                                             | Pass/Fail |
| ------------------ | ---------------------- | ------------------------------------------------------ | ----------------------------------------------------------------- | --------- |
| Insert enemy class | Simply begin the game. | The enemy should load in, a quarter of the page down.  | The enemy doesn't appear                                          | Fail      |
| Insert enemy class | Simply begin the game. | The enemy should load in, a quarter of the page down.  | The enemy appears in the right place, with the texture and size.  | Pass      |
|                    |                        |                                                        |                                                                   |           |

### Evidence <a href="#evidence" id="evidence"></a>
