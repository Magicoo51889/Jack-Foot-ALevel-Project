# 2.2.3 Cycle 3

## Design <a href="#design" id="design"></a>

### Objectives <a href="#objectives" id="objectives"></a>

In this cycle I aim to be creating an enemy class that I can re-use to reduce the amount of code being written, so that the game is smaller to load and run. This makes it less intensive for slower computers and means that my code is better structured and easier to read/debug. Additionally I will add all the enemies to an array to be able to make them grouped together and to be able to call different elements in the array for different enemy types, making it easier to quickly add an enemy later on in the game's development.&#x20;

Furthermore I will be implementing a key system to be able to identify different objects in the game so that I can track what object is which with a simple sting of characters, which could be in 4 bit binary as this would allow for 16 different unique keys for things such as the player or the player's lasers, or the enemies.

* [x] Create enemy class
* [ ] Enemy loads into the game
* [ ] Unique object keys

### Usability Features <a href="#usability-features" id="usability-features"></a>

### Key Variables <a href="#key-variables" id="key-variables"></a>

| Variable Name       | Use                                                                                                                                            |
| ------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| \[OBJECT]\_CATEGORY | This constant is one that is assigned to each different object, which is unique to that one object, and makes identifying each object easier.  |

### Pseudocode <a href="#pseudocode" id="pseudocode"></a>

```
class Enemy extends Phaser Sprite
    target = this.target
    scene = current scene
    
    scene: Phaser.scene
    X: Number
    Y: Number
    texture: string
    
    create(texture)
        add image (X, Y, texture)
        
    set the this.target as the target
    
    procedure Update
        if target doesn't exist
            return
        else
            tx = target.x
            ty = target.y
            x = this.x
            y = this.y
            rotation = angle between (tx and ty, x and y)
            rotate to rotation
    end procedure
end class
            
        
```

## Development <a href="#development" id="development"></a>

### Outcome <a href="#outcome" id="outcome"></a>

{% tabs %}
{% tab title="enemy.ts" %}
```typescript
import Phaser from "phaser";

export default class Enemy extends Phaser.GameObjects.Sprite {
    private target?: Phaser.GameObjects.Components.Transform;
    scene: Phaser.Scene;

    constructor(scene: Phaser.Scene, x: number, y: number, texture: string) {
        super(scene, 0, 0, texture);
        this.scene = scene;
    }

    create(texture: string) {
        this.scene.add.image(0, 0, texture); // This finds the image being used for the enemies and loads it
        console.log("enemy created");
    }

    set_Target(target: Phaser.GameObjects.Components.Transform) {
        this.target = target;
        console.log("finding target");
    }

    update() {
        // points towards the player
        if (!this.target){
            console.log("no target"); // This checks to see if there's a target
            return
        }
        
        console.log("target found");
        const tx = this.target.x 
        const ty = this.target.y
        const x = this.x
        const y = this.y
        const rotation = Phaser.Math.Angle.Between(x, y, tx, ty) // This positions the enemy to look towards the player
        this.setRotation(rotation)
        console.log("rotating to " + rotation);
    }y.
}
```
{% endtab %}

{% tab title="Second Tab" %}

{% endtab %}
{% endtabs %}

### Challenges <a href="#challenges" id="challenges"></a>

It was quite challenging to work out and figure what functionality I first needed in my enemy class to be able to get it to work, and I needed to figure out what would be essential and found in every enemy that I made. This means that every enemy I made had to have all of these common features, so it was essential that I got them right.&#x20;

Additionally the way in which I add a class as a new sprite was new to me so making it work properly without any bugs or issues, was a bit tricky to begin with, but I soon found out how to do it properly, and make sure that I was passing in each bit of information properly.

## Testing <a href="#testing" id="testing"></a>

Evidence for testing

### Tests <a href="#tests" id="tests"></a>

| Test | Instructions | What I expect | What actually happens | Pass/Fail |
| ---- | ------------ | ------------- | --------------------- | --------- |
|      |              |               |                       |           |
|      |              |               |                       |           |
|      |              |               |                       |           |

### Evidence <a href="#evidence" id="evidence"></a>
